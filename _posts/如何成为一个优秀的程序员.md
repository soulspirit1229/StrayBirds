# 如何成为一个优秀的程序员

<!-- create time: 2014-11-22 08:00:15  -->

如何成为一个优秀的程序员，这是个程序员都必须要思考的问题。如果是单纯的着眼于技术上的酷炫，标新求异，那么优秀的程序员总是顶尖的那几个。但如果是着眼于如何正确，快速的完成客户所提的要求，着眼于解决客户的需求，那么这就是个优秀的程序员。这个是社会给予程序员的期望，正如我们期望去医院，医生能给我们治病一样，我们不期望医生说一定要给我们用最新的技术，而是快点给我们治好病，不是吗？

## Quarlity

>###### Perl语言的发明人Larry Wall说，好的程序员有3种美德： 懒惰、急躁和傲慢（Laziness, Impatience and hubris）。
>>#####懒惰：
是这样一种品质，它使得你花大力气去避免消耗过多的精力。它敦促你写出节省体力的程序，同时别人也能利用它们。为此你会写出完善的文档，以免别人问你太多问题。

>>#####急躁：
是这样一种愤怒----当你发现计算机懒洋洋地不给出结果。于是你写出更优秀的代码，能尽快真正的解决问题。至少看上去是这样。

>>#####傲慢：
极度的自信，使你有信心写出（或维护）别人挑不出毛病的程序。

## 动手之前先思考
>##### 在任何一个领域，优秀者总是拥有比平庸者更多甚至多得多的好习惯。而最重要的好习惯，是动手之前先思考。

>##### 昨天我们带孩子去听一场钢琴独奏音乐会，演奏者是一位天才少年。少年在演奏每一首曲子前，都会把手放在膝盖上，静默十余秒，我们知道那是在脑海中迅速地对他要演奏的曲子“过电影”，这便是思考。然后他的大脑便驾驭着他的双手，奏出美妙的乐曲。

>##### 每次带孩子学琴，德高望重的银发钢琴老师都喜欢和我们点评前后学琴的孩子，他最夸奖的，是一位坐上琴凳后，会静静地等几秒钟才开始弹奏的小姑娘，老师说，10个琴童中难得挑出一个这样的孩子。我们家的孩子性子躁，但也在老师每每的严格要求下，被训练着能在急于动手开始弹奏前，先双手放在膝盖上，静默数秒——思考要弹奏的曲子的难点、节奏，开始和结尾。只要女儿能做到这一点，她的弹奏都会得到老师的夸奖，但有时她心浮气躁，坐到琴旁就开始弹奏，琴声也带着躁性，这时就会被老师喝止。

>##### 大家常说能坚持练琴的孩子，做什么都会更有耐心。我们这些家长对此是认同的，身为学琴6年的女儿的家长，我们对比了不同的老师，现在这位老师才是我们最满意的，因为他会狠抓女儿的基本功，而此前的几位老师对基本功都有些忽视，这使得女儿越是弹奏难度高的曲子，越是能发现基本功不扎实带来的苦恼，所以回过头还是要补这些基本功，侥幸不得。因此，今年考8级（业余）的女儿，一边练习有难度的乐曲，一边丝毫不敢掉以轻心地每天按照老师的要求弹奏练习曲。

## 成熟思考？？
>##### 以顺序概念为例，不成熟的程序员往往会采用自底向上的思维方式来开发程序。 他们先考虑程序的具体实现，然后再考虑功能设计、最后考虑构架设计。 而成熟的程序员则采用自顶向下思维方式，先考虑构架设计、再考虑功能设计、 最后才考虑编程的具体实现。 前者思维方式主要是出于工作惯性，只适合入门阶段，而后者思维方式反映了后者的进步，适用于各种项目开发或大型项目的开发。

## 知其然，知其所以然

## 刻意练习

>#####国外的技术问答社区StackOverflow，有个帖子讨论得很火，说的正是“How does a programmer employ deliberate practice? （程序员如何应用'刻意练习'）”。

>#####程序员进行“刻意练习”，最早是在《Software Craftmanship（软件工艺）》一书中正式提到，新出的《程序员应该知道的97件事》也有一小节提及。但最系统、详尽讨论的是《Apprenticeship Patterns: Guidance for the Aspiring Software Craftsman（软件开发者路线图：从学徒到高手）》，可以称得上是程序员“刻意练习”的一本行动教科书。

>#####程序员进行”刻意练习“，与其他领域相比有一个天然优势，就是可以充分利用网络和开源。除了《软件开发者路线图：从学徒到高手》提到的方法，Hacker News技术社区的讨论还建议了一些网络资源，如Coding Dojo（编程擂台）、Code Kata（精心设计的21个编程练习），Ruby社区的Ruby Quiz邮件列表等。

>#####优秀的开源代码也是很好的学习对象。StackOverflow问答社区建议，可以借鉴富兰克林学习写作的方法，分析一段优秀的开源代码，梳理逻辑、做好笔记，然后尝试自己重新实现，再与源代码进行比对。这个过程可以循环递进地进行。

## 不正常的现象

>##### 首先，这个行业的确存在很多重复劳动，因为大家都不愿意购买或者说获得授权使用别人的成果，很多工程之所以劳师动众，很大程度上是因为无法借鉴或者舍不得购买前人已有的算法成果和有效的代码模块。这就好比造汽车的企业明明没有发动机的研发功能，却不想花钱采购发动机。你看，这在实体产业中是可笑的，但是在软件行业中，却是常常出现的现象，尤其是当企业领导或者项目经理拥有一个其他行业的背景的时候。 很多人的说法是，反正别人能写出来，你为什么写不出来？问题是，已经有高人写出来了，为什么我这个菜鸟还要写，而且拿着这么低的工资却要求我写出天才的代码？

>##### 第二，这个行业的确存在很多的外行领导内行，前面说的企业领导或者项目经理的问题是一种情况，更为普遍的是，大家觉得软件是无所不能的，所以软件开发者也应该是无所不能的，不遵循软件开发的规律，不激发开发人员的创造力和协作配合精神，以为强调纪律就是一切。这种遭遇很多资深程序员都遭遇过，但是想想为什么松松垮垮的谷歌可以成功，而治军严谨的富士康为什么没有啥拿的出手的软件产品（富士康是有很大软件开发团队的，只不过战绩拿不出手，所以一直不怎么露脸）。

>###### 第三，这个行业里面有一大堆不合格的人。很多人是半路出家，很多人就是大忽悠，可以吹牛，但是编程水平太差，很多人根本不会查文档，很多人完全不喜欢这份工作，巴不得这是一份不费脑筋，每天到点下班、每月按时拿钱的近乎前台的工作。

## 现代软件工程 课件 软件工程师能力自我评价表

1.保持高标准，不要受制于破窗理论(broken windows theory)[i]。
当你看到不靠谱的设计、糟糕的代码、过时的文档和测试用例的时候，不要想“既然别人的代码已经这样了，我的代码也可以随便一点啦。”

2. 主动解决问题。当看到不靠谱的设计，糟糕的代码的时候，不要想“可能别人会来管这个事情” ，或者“我下个月发一个邮件让大家讨论一下”。要主动地把问题给解决了[ii]。

3. 经常给自己充电，身体训练是运动员生活的一部分，学习是软件工程师职业的伴侣。每半年就要了解和学习一些新的相关技术。通过定期分享（面对面的分享，写技术博客等）来确保自己真正掌握了新技术。

4. DRY （Don't Repeat Yourself）——别重复。在一个系统中，每一个知识点都应该有一个无异议的、正规的表现形式。

5. 消除不相关模块之间的影响，在设计模块的时候，要让它们目标明确并单一，能独立存在，没有不明确的外部依赖。

6. 通过快速原型来学习，快速原型的目的是学习，它的价值不在于代码，而在于你通过快速原型学到了什么。

7. 设计要接近问题领域，在设计的时候，要接近你目标用户的语言和环境。

8. 估计任务所花费的时间，避免意外。在开始工作的时候，要做出时间和潜在影响的估计，并通告相关人士，避免最后关头意外发生。

9. 图形界面的工具有它的长处，但是不要忘了命令行工具也可以发挥很高的效率，特别是可以用脚本构建各种组合命令的时候。

10. 有很多代码编辑器，请把其中一个用得非常熟练。让编辑器可以实现自己的定制，可以用脚本驱动，用起来得心应手。

11. 理解常用的设计模式，并知道择机而用。设计模式不错，更重要的是知道它的目的是什么，什么时候用，什么时候不用。

12. 代码版本管理工具是你代码的保障，重要的代码一定要有代码版本管理。

13. 在debug的时候，不要惊慌，想想导致问题的原因可能在哪里。一步一步地找到原因。要在实践中运用工具，善于分析日志（log），从中找到bug。同时，在自己的代码里面加 log.

14. 重要的接口要用形式化的“合同”来规定。用文档和断言、自动化测试等工具来保证代码的确按照合同来做事，不多也不少。使用断言 (assertion) 或者其他技术来验证代码中的假设，你认为不可能发生的事情在现实世界中往往会发生。

15. 只在异常的情况下才使用异常 (Exception),  不加判断地过多使用异常，会降低代码的效率和可维护性。记住不要用异常来传递正常的信息。

16. 善始善终。如果某个函数申请了空间或其他资源，这个函数负责释放这些资源。

17. 当你的软件有多种技术结合在一起的时候，要采用松耦合的配置模式，而不是要把所有代码都集成到一起。

18. 把常用模块的功能打造成独立的服务，通过良好的界面 (API) 来调用不同的服务。[YEKA1]

19. 在设计中考虑对并行的支持，这样你的API 设计会比较容易扩展。

20. 在设计中把展现模块 (View) 和实体模块 (Model) 分开，这样你的设计会更有灵活性。

21. 重视算法的效率，在开始写之前就要估计好算法的效率是哪一个数量级上的（big-O）。

22. 在实际的运行场景中测试你的算法，不要停留在数学分析层面。有时候一个小小的实际因素 (是否支持大小写敏感的排序，数据是否支持多语言)会导致算法效率的巨大变化。

23. 经常重构代码，同时注意要解决问题的根源。

24. 在开始设计的时候就要考虑如何测试 ，如果代码出了问题，有log 来辅助debug 么? 尽早测试，经常测试，争取实现自动化测试，争取每一个构建的版本都能有某些自动测试。

25. 代码生成工具可以生成一堆一堆的代码，在正式使用它们之前，要确保你能理解它们，并且必要的时候能debug 这些代码。

26. 和一个实际的用户一起使用软件，获得第一手反馈。

27. 在自动测试的时候，要有意引地入bug，来保证自动测试的确能捕获这些错误。

28. 如果测试没有做完，那么开发也没有做完。

29. 适当地追求代码覆盖率：每一行的代码都覆盖了，但是程序未必正确。要确保程序覆盖了不同的程序状态和各种组合条件。

30. 如果团队成员碰到了一个有普遍意义的bug,  应该建立一个测试用例抓住以后将会出现的类似的bug。

31. 测试：多走一步，多考虑一层。如果程序运行了一星期不退出，如果用户的屏幕分辨率再提高一个档次，这个程序会出什么可能的错误?

32. （带领团队）了解用户的期望值，稍稍超出用户的期望值，让用户有惊喜。

33.  (带领团队) 不要停留在被动地收集需求，要挖掘需求。真正的需求可能被过时的假设、对用户的误解或其他因素所遮挡。

34. （带领团队）把所有的术语和项目相关的名词、缩写等都放在一个地方。

35. （带领团队）不要依赖于某个人的手动操作，而是要把这些操作都做成有相关权限的人士都能运行的脚本。这样就不会出现因为某人休假而项目被卡住的情况。

36. （带领团队）要让重用变得更容易。一个软件团队要创造一种环境，让软件的重用变得更容易。

37. （带领团队）在每一次迭代之后，都要总结经验，让下一次迭代的日程安排更可靠。


## 程序员的五个境界

在我平时所见到的程序员中，如果纯以编码能力来看，个人觉得可以分为五类，依次是：

1. 拷贝型
拷贝型选手就是传说中的“代码拷贝员”了，他们对实现功能几乎没有思路，所作的事情就是从网上或是之前其他团队成员写的代码中拷贝出片段，然后放到项目中，如果运行项目出现了期望结果，则表示任务完成。
这类人只会改代码，却不会写代码。他们大多对编程毫无兴趣，只是希望以此糊口而已。

2. 新手型
当产品有功能需求时，由于经验有限，程序员并不完全知道要如何实现这个功能，需要通过学习、寻找资料等方式来解决问题。
这种情况下的编码过程，程序员的主要目标是“完成功能”，那么很难有多余的心思去考虑边界条件、性能、可读性、可扩展性、编码规范等问题，因此代码bug可能较多，稳定性不高。常常会发生开发花费1个月，改bug却要改上好几个月的事情。

3. 学习型
这类程序员对所在领域的语言已经比较了解，对于一般功能可以有较为清晰的实现思路，给出需求时可以通过自己的思路来实现，并且会一定程度上考虑边界条件和性能问题。但仅此而已，他们对可读性和可扩展性考虑很少，也没有项目级别的考虑，主要是希望通过实现代码来练手或是学习。
这类程序员最大的表现在于喜欢“创造代码”，即使有现成的实现，他们也希望自己来实现一套，以达到“学习”的目的。他们不喜欢复用别人的代码，看见项目中别人实现了相类似的功能，他们会以“需求不同”的借口来自己重新实现一套。这类人一般来说对技术有着较为浓厚的兴趣，希望能够通过项目来进行学习。
从项目的角度来说，这种做法最大的麻烦在于开发周期可能较长（相比直接使用现成的实现），并且会使得项目代码膨胀，影响未来的维护。但这类程序员由于有兴趣，如果好好培养或许会成为明天的牛人。

4. 实现型
这类程序员一般有较为丰富的经验，由于写得太多，因此不再追求“创造代码”来进行学习，同时对所在领域可能涉及的很多第三方框架或是工具都比较熟悉，当接受到产品需求时，对功能实现方案已经了然于胸，因此他们可以快速的实现需求，并且对边界、性能都有一定程度的考虑。因为能够快速实现需求功能，经常会被团队评价为“牛人”。但他们一般仅仅停留在“完成功能”级别上，对代码的可读性、可扩展性、编码规范等考虑较少，对项目总体把握也较少（例如控制项目膨胀、方便部署等架构级别的东西）。
这类程序员最大的表现在于喜欢“开发项目”，却不喜欢“维护项目”。他们产出的代码最大的问题就是维护较为困难，可能过上几个月回头看自己的代码都会晕头转向。因此即使是自己写的代码，仍然不愿意维护，一般会苦了后来人。
因为接口设计的缺乏，当需求变更时，发现代码要改的东西太多，然后抱怨需求变化，却很少认为是自己的代码问题。这样的项目如果经过长时间的变更维护，最终会变得难以维护（一般表现在需求变更响应时间越来越长）甚至无法维护，最终要么是半死不活，要么是被推倒重来。

5. 架构型
这类程序员比实现型更进一步，他们经验丰富，对相关框架和工具等都很熟悉，“完成功能”“稳定性”“性能”这些已经不再是他们的追求，更优美的代码、更合理的架构才是目标。
这类程序员代码设计大多建立在对需求的详细了解和对需求变更的预测上——可扩展性较好；代码细节也尽量多的考虑边界情况、性能——稳定高效；代码命名和注释都恰到好处——可读性较高；同时在开发过程中他们会不断重构，对代码做减法——保证项目可持续发展；等等
但由于考虑问题较多，单从“实现功能”阶段来看，完成速度不一定会比“实现型”要快。只是到了项目中后期优势才会慢慢体现出来



