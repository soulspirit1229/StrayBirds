<!DOCTYPE html>
<html>
    <head>
        <!--
         **
         * Auther:      掌心
         * Contact:     http://www.zhanxin.info
         * Create:      2013.08.10
         * Theme Name:  Kunka
         * Authorize:   BY-NC-SA
         **
        -->
        <meta charset="utf-8">
        <title>One Day One Question - ruby中的闭包 - 逍遥游</title>
        <!-- meta -->
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
        <meta name="generator" content="Jekyll" />
        <meta name="author" content="soulspirit" />
        <meta name="description" content="大知闲闲，小知间间；大言炎炎，小言詹詹。" />
        <meta name="keywords" content="" />
        <!-- atom -->
        <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/blog/atom.xml" />
        <link rel="shortcut icon" href="http://jekyllrb.com/favicon.png" type="image/x-icon" />
        <!-- font-awesome -->
        <link href="//netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet">
        <link href='http://fonts.googleapis.com/css?family=Spirax' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="/blog/themes/kunka/css/syntax.css">
        <link rel="stylesheet" href="/blog/themes/kunka/css/main.css">
        
    </head>
    <body>
        <div class="head fn-clear">
            <div class="header">
                <h1 class="logo">
                    <a href="/blog/"><i class="icon-anchor"></i></a>
                </h1>
                <nav class="nav">
                    <ul>
                        
                        
                        
                        <li class="nav-item ">
                            <a href="/blog/index.html">
                                首页
                            </a>
                            
                        </li>
                        
                        
                        
                        <li class="nav-item ">
                            <a href="/blog/navigations/categories.html">
                                分类目录
                            </a>
                            
                        </li>
                        
                        
                        
                        <li class="nav-item ">
                            <a href="/blog/navigations/archives.html">
                                文章归档
                            </a>
                            
                        </li>
                        
                        
                        
                        <li class="nav-item ">
                            <a href="/blog/navigations/contact.html">
                                联系我
                            </a>
                            
                        </li>
                        
                        
                        
                        <li class="nav-item ">
                            <a href="/blog/navigations/links.html">
                                友情链接
                            </a>
                            
                        </li>
                        
                    </ul>
                </nav>
                <div class="follow">
                    
                    <a href="/atom.xml" target="_blank"><i class="icon-rss"></i></a>
                    
                    <a href="http://weibo.com" target="_blank"><i class="icon-weibo"></i></a>
                    
                    <a href="http://renren.com" target="_blank"><i class="icon-renren"></i></a>
                    
                    <a href="http://github.com" target="_blank"><i class="icon-github-alt"></i></a>
                    
                    <a href="http://twitter.com" target="_blank"><i class="icon-twitter"></i></a>
                    
                    <a href="http://google.com" target="_blank"><i class="icon-google-plus"></i></a>
                    
                </div>
            </div>
        </div>
        <div class="contain fn-clear">
            <div class="container fn-clear">
                <div class="main">
                    
    <div class="article article-post">
    <h2 class="title">One Day One Question - ruby中的闭包</h2>
    <div class="info">
        <span class="info-title"><i class="icon-calendar"></i> Published: </span>
        <span class="info-date">23 Jul 2015</span>
        <span class="info-title"><i class="icon-folder-open"></i> Category: </span>
        <span class="info-link"><a href="/StrayBirds/navigations/categories.html#ODOQ-ref" >ODOQ</a></span>
    </div>
    <h1>ODOQ - ruby中的闭包</h1>
<div class="highlight"><pre><code class="language-rb" data-lang="rb"><span class="c1"># CLOSURES IN RUBY     Paul Cantrell    http://innig.net</span>
<span class="c1"># Email: username &quot;cantrell&quot;, domain name &quot;pobox.com&quot;</span>
<span class="c1">#</span>
<span class="c1"># 翻译: kenshin54     http://kenbeit.com</span>

<span class="c1"># I recommend executing this file, then reading it alongside its output.</span>
<span class="c1"># 我强烈建议执行此脚本，然后根据它的输出来理解它。</span>
<span class="c1">#</span>
<span class="c1"># Alteratively, you can give yourself a sort of Ruby test by deleting all the comments,</span>
<span class="c1"># then trying to guess the output of the code!</span>
<span class="c1"># 或者，你可以给自己做一个ruby测试，删除所有的注释，然后猜测代码输出的结果</span>

<span class="c1"># A closure is a block of code which meets three criteria:</span>
<span class="c1"># 闭包是一个满足3个标准的代码块：</span>
<span class="c1"># </span>
<span class="c1">#     * It can be passed around as a value and</span>
<span class="c1">#     * 它可以作为一个值被传入</span>
<span class="c1"># </span>
<span class="c1">#     * executed on demand by anyone who has that value, at which time</span>
<span class="c1">#     * 在任何时候根据不同人的需要来执行它</span>
<span class="c1"># </span>
<span class="c1">#     * it can refer to variables from the context in which it was created</span>
<span class="c1">#       (i.e. it is closed with respect to variable access, in the</span>
<span class="c1">#       mathematical sense of the word &quot;closed&quot;).</span>
<span class="c1">#     * 它可以使用创建它的那个上下文中的变量（即它是对封闭变量的访问，数学意义上的词“封闭”）</span>
<span class="c1">#</span>
<span class="c1"># (The word &quot;closure&quot; actually has an imprecise meaning, and some people don&#39;t</span>
<span class="c1"># think that criterion #1 is part of the definition. I think it is.)</span>
<span class="c1"># （词“闭包”实际上有一个不明确的意义，有一些人不认为标准#1是它定义的一部分，但我认为它是。）</span>
<span class="c1"># </span>
<span class="c1"># Closures are a mainstay of functional languages, but are present in many other</span>
<span class="c1"># languages as well (e.g. Java&#39;s anonymous inner classes). You can do cool stuff</span>
<span class="c1"># with them: they allow deferred execution, and some elegant tricks of style.</span>
<span class="c1"># 闭包是一个函数式语言的主体，但是也存在与其他很多语言中（比如Java中的匿名内部类）。</span>
<span class="c1"># 你可以用它来做一些很酷的东西：他们可以延后执行，和一些优雅的技巧。</span>
<span class="c1"># </span>
<span class="c1"># Ruby is based on the &quot;principle of least surprise,&quot; but I had a really nasty</span>
<span class="c1"># surprise in my learning process. When I understood what methods like &quot;each&quot;</span>
<span class="c1"># were doing, I thought, &quot;Aha! Ruby has closures!&quot; But then I found out that a</span>
<span class="c1"># function can&#39;t accept multiple blocks -- violating the principle that closures</span>
<span class="c1"># can be passed around freely as values.</span>
<span class="c1"># Ruby基于“最小惊讶原则”，但是在我的学习过程中却是感到了惊讶。当我理解像“each”</span>
<span class="c1"># 这样的方法在做什么时，我想，“啊，Ruby有闭包！”。但是我发现一个函数无法接收</span>
<span class="c1"># 多个块——违反闭包可以被任意的传递值的原则。</span>
<span class="c1"># </span>
<span class="c1"># This document details what I learned in my quest to figure out what the deal is</span>
<span class="c1"># 这个文档详述了在我弄清闭包的处理时我所学到的东西。</span>

<span class="k">def</span> <span class="nf">example</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="nb">puts</span>
    <span class="nb">puts</span> <span class="s2">&quot;------ Example </span><span class="si">#{</span><span class="n">num</span><span class="si">}</span><span class="s2"> ------&quot;</span>
<span class="k">end</span>

<span class="c1"># ---------------------------- Section 1: Blocks ----------------------------</span>
<span class="c1"># -------------------------------- 章节一：块 -------------------------------</span>

<span class="c1"># Blocks are like closures, because they can refer to variables from their defining context:</span>
<span class="c1"># 块就像闭包，因为他们可以使用定义它们的那个上下文中的变量。</span>

<span class="n">example</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">thrice</span>
    <span class="k">yield</span>
    <span class="k">yield</span>
    <span class="k">yield</span>
<span class="k">end</span>

<span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
<span class="nb">puts</span> <span class="s2">&quot;value of x before: </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="n">thrice</span> <span class="p">{</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">}</span>
<span class="nb">puts</span> <span class="s2">&quot;value of x after: </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># A block refers to variables in the context it was defined, not the context in which it is called:</span>
<span class="c1"># 一个块使用定义它的上下文中的变量，而不是被调用的上下文中的变量。</span>

<span class="n">example</span> <span class="mi">2</span>

<span class="k">def</span> <span class="nf">thrice_with_local_x</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="k">yield</span>
    <span class="k">yield</span>
    <span class="k">yield</span>
    <span class="nb">puts</span> <span class="s2">&quot;value of x at end of thrice_with_local_x: </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">end</span>

<span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">thrice_with_local_x</span> <span class="p">{</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">}</span>
<span class="nb">puts</span> <span class="s2">&quot;value of outer x after: </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># A block only refers to *existing* variables in the outer context; if they don&#39;t exist in the outer, a</span>
<span class="c1"># block won&#39;t create them there:</span>
<span class="c1"># 一个块仅仅使用定义它的上下文中已经存在的变量，如果变量不存在外于部上下文，块不会去创建他们。</span>

<span class="n">example</span> <span class="mi">3</span>

<span class="n">thrice</span> <span class="k">do</span> <span class="c1"># note that {...} and do...end are completely equivalent 注意{...}和do...end是完全相等的</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="nb">puts</span> <span class="s2">&quot;Is y defined inside the block where it is first set?&quot;</span>
    <span class="nb">puts</span> <span class="s2">&quot;Yes.&quot;</span> <span class="k">if</span> <span class="n">defined?</span> <span class="n">y</span>
<span class="k">end</span>
<span class="nb">puts</span> <span class="s2">&quot;Is y defined in the outer context after being set in the block?&quot;</span>
<span class="nb">puts</span> <span class="s2">&quot;No!&quot;</span> <span class="k">unless</span> <span class="n">defined?</span> <span class="n">y</span>

<span class="c1"># OK, so blocks seem to be like closures: they are closed with respect to variables defined in the context</span>
<span class="c1"># where they were created, regardless of the context in which they&#39;re called.</span>
<span class="c1"># </span>
<span class="c1"># But they&#39;re not quite closures as we&#39;ve been using them, because we have no way to pass them around:</span>
<span class="c1"># &quot;yield&quot; can *only* refer to the block passed to the method it&#39;s in.</span>
<span class="c1">#</span>
<span class="c1"># We can pass a block on down the chain, however, using &amp;:</span>
<span class="c1"># 所以块看起来像闭包：他们封闭了定义它们的上下文中的变量，不管他们在哪里调用。</span>
<span class="c1"># 但是在我们使用它们时，它们不完全是闭包，因为我们没有办法传递他们。</span>
<span class="c1"># “yield”仅仅可以将块传给它所在的方法。</span>

<span class="n">example</span> <span class="mi">4</span>

<span class="k">def</span> <span class="nf">six_times</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">thrice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">thrice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">x</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">six_times</span> <span class="p">{</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">10</span> <span class="p">}</span>
<span class="nb">puts</span> <span class="s2">&quot;value of x after: </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># So do we have closures? Not quite! We can&#39;t hold on to a &amp;block and call it later at an arbitrary</span>
<span class="c1"># time; it doesn&#39;t work. This, for example, will not compile:</span>
<span class="c1">#</span>
<span class="c1"># def save_block_for_later(&amp;block)</span>
<span class="c1">#     saved = &amp;block;</span>
<span class="c1"># end</span>
<span class="c1">#</span>
<span class="c1"># But we *can* pass it around if we use drop the &amp;, and use block.call(...) instead of yield:</span>
<span class="c1"># 所以我们是否有闭包？不完全！我们不能保存一个&amp;block，然后稍后在任意时间来调用它。</span>
<span class="c1"># 但是如果我们丢掉&amp;，我们就有办法传递它了，使用block,call(...)代替yield。</span>

<span class="n">example</span> <span class="mi">5</span>

<span class="k">def</span> <span class="nf">save_for_later</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="vi">@saved</span> <span class="o">=</span> <span class="n">b</span>  <span class="c1"># Note: no ampersand! This turns a block into a closure of sorts. 注意：没有&amp;符号！这个做法将一个块变成了一个闭包。</span>
<span class="k">end</span>

<span class="n">save_for_later</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">&quot;Hello!&quot;</span> <span class="p">}</span>
<span class="nb">puts</span> <span class="s2">&quot;Deferred execution of a block:&quot;</span>
<span class="vi">@saved</span><span class="o">.</span><span class="n">call</span>
<span class="vi">@saved</span><span class="o">.</span><span class="n">call</span>

<span class="c1"># But wait! We can&#39;t pass multiple blocks to a function! As it turns out, there can be only zero</span>
<span class="c1"># or one &amp;block_params to a function, and the &amp;param *must* be the last in the list.</span>
<span class="c1">#</span>
<span class="c1"># None of these will compile:</span>
<span class="c1">#</span>
<span class="c1">#    def f(&amp;block1, &amp;block2) ...</span>
<span class="c1">#    def f(&amp;block1, arg_after_block) ...</span>
<span class="c1">#    f { puts &quot;block1&quot; } { puts &quot;block2&quot; }</span>
<span class="c1">#</span>
<span class="c1"># What the heck?</span>
<span class="c1">#</span>
<span class="c1"># I claim this single-block limitation violates the &quot;principle of least surprise.&quot; The reasons for</span>
<span class="c1"># it have to do with ease of C implementation, not semantics.</span>
<span class="c1">#</span>
<span class="c1"># So: are we screwed for ever doing anything robust and interesting with closures?</span>
<span class="c1"># 等等！我们不能传递多个块给一个函数！一个函数只能接收0或1个&amp;block_params参数，并且&amp;block_params必须是最后一个参数。</span>
<span class="c1"># 我觉得这个单block违反了最小惊讶原则，因为这很容用C来实现，不是语义上的。</span>


<span class="c1"># ---------------------------- Section 2: Closure-Like Ruby Constructs ----------------------------</span>
<span class="c1"># --------------------------------- 章节二：闭包风格的Ruby构造器 ----------------------------------</span>

<span class="c1"># Actually, no. When we pass a block &amp;param, then refer to that param without the ampersand, that</span>
<span class="c1"># is secretly a synonym for Proc.new(&amp;param):</span>
<span class="c1"># 实际上，没有。当我们传递一个块&amp;param，然后不带&amp;来使用param，这是Proc.new(&amp;param)的隐式同义词。</span>

<span class="n">example</span> <span class="mi">6</span>

<span class="k">def</span> <span class="nf">save_for_later</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="vi">@saved</span> <span class="o">=</span> <span class="no">Proc</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="c1"># same as: @saved = b</span>
<span class="k">end</span>

<span class="n">save_for_later</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">&quot;Hello again!&quot;</span> <span class="p">}</span>
<span class="nb">puts</span> <span class="s2">&quot;Deferred execution of a Proc works just the same with Proc.new:&quot;</span>
<span class="vi">@saved</span><span class="o">.</span><span class="n">call</span>

<span class="c1"># We can define a Proc on the spot, no need for the &amp;param:</span>
<span class="c1"># 我们可以随意定义一个Proc，不需要&amp;param。</span>

<span class="n">example</span> <span class="mi">7</span>

<span class="vi">@saved_proc_new</span> <span class="o">=</span> <span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">&quot;I&#39;m declared on the spot with Proc.new.&quot;</span> <span class="p">}</span>
<span class="nb">puts</span> <span class="s2">&quot;Deferred execution of a Proc works just the same with ad-hoc Proc.new:&quot;</span>
<span class="vi">@saved_proc_new</span><span class="o">.</span><span class="n">call</span>

<span class="c1"># Behold! A true closure!</span>
<span class="c1">#</span>
<span class="c1"># But wait, there&#39;s more.... Ruby has a whole bunch of things that seem to behave like closures,</span>
<span class="c1"># and can be called with .call:</span>
<span class="c1"># 看！一个真的闭包！</span>
<span class="c1"># 等等，还有跟精彩的。。。Ruby还有一堆东西的行为看起来像闭包，并且能用.call来调用。</span>

<span class="n">example</span> <span class="mi">8</span>

<span class="vi">@saved_proc_new</span> <span class="o">=</span> <span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">&quot;I&#39;m declared with Proc.new.&quot;</span> <span class="p">}</span>
<span class="vi">@saved_proc</span> <span class="o">=</span> <span class="nb">proc</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">&quot;I&#39;m declared with proc.&quot;</span> <span class="p">}</span>
<span class="vi">@saved_lambda</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">&quot;I&#39;m declared with lambda.&quot;</span> <span class="p">}</span>
<span class="k">def</span> <span class="nf">some_method</span> 
    <span class="nb">puts</span> <span class="s2">&quot;I&#39;m declared as a method.&quot;</span>
<span class="k">end</span>
<span class="vi">@method_as_closure</span> <span class="o">=</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:some_method</span><span class="p">)</span>

<span class="nb">puts</span> <span class="s2">&quot;Here are four superficially identical forms of deferred execution:&quot;</span>
<span class="vi">@saved_proc_new</span><span class="o">.</span><span class="n">call</span>
<span class="vi">@saved_proc</span><span class="o">.</span><span class="n">call</span>
<span class="vi">@saved_lambda</span><span class="o">.</span><span class="n">call</span>
<span class="vi">@method_as_closure</span><span class="o">.</span><span class="n">call</span>

<span class="c1"># So in fact, there are no less than seven -- count &#39;em, SEVEN -- different closure-like constructs in Ruby:</span>
<span class="c1">#</span>
<span class="c1">#      1. block (implicitly passed, called with yield)</span>
<span class="c1">#      2. block (&amp;b  =&gt;  f(&amp;b)  =&gt;  yield)  </span>
<span class="c1">#      3. block (&amp;b  =&gt;  b.call)    </span>
<span class="c1">#      4. Proc.new  </span>
<span class="c1">#      5. proc  </span>
<span class="c1">#      6. lambda    </span>
<span class="c1">#      7. method</span>
<span class="c1">#</span>
<span class="c1"># Though they all look different, some of these are secretly identical, as we&#39;ll see shortly.</span>
<span class="c1">#</span>
<span class="c1"># We already know that (1) and (2) are not really closures -- and they are, in fact, exactly the same thing.</span>
<span class="c1"># Numbers 3-7 all seem to be identical. Are they just different syntaxes for identical semantics?</span>

<span class="c1"># ---------------------------- Section 3: Closures and Control Flow ----------------------------</span>
<span class="c1"># ---------------------------------- 章节三：闭包后控制流 --------------------------------------</span>

<span class="c1"># No, they aren&#39;t! One of the distinguishing features has to do with what &quot;return&quot; does.</span>
<span class="c1">#</span>
<span class="c1"># Consider first this example of several different closure-like things *without* a return statement.</span>
<span class="c1"># They all behave identically:</span>
<span class="c1"># 实际上Ruby有不少于7中不同的闭包风格的构造器</span>
<span class="c1"># ...</span>
<span class="c1"># 尽管他们看起来不一样，有些其实是完全相同的，我们后面马上会看到。</span>
<span class="c1"># 我们已经知道(1)和(2)不是真正的闭包，其实(1)和(2)是同样的东西。</span>
<span class="c1"># 3-7看上去是完全一样的，他们是不是语义相同的不用语法？</span>

<span class="n">example</span> <span class="mi">9</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">closure</span><span class="p">)</span>
    <span class="nb">puts</span>
    <span class="nb">puts</span> <span class="s2">&quot;About to call closure&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">closure</span><span class="o">.</span><span class="n">call</span>
    <span class="nb">puts</span> <span class="s2">&quot;Closure returned: </span><span class="si">#{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="s2">&quot;Value from f&quot;</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="s2">&quot;f returned: &quot;</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="s2">&quot;Value from Proc.new&quot;</span> <span class="p">})</span>
<span class="nb">puts</span> <span class="s2">&quot;f returned: &quot;</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="nb">proc</span> <span class="p">{</span> <span class="s2">&quot;Value from proc&quot;</span> <span class="p">})</span>
<span class="nb">puts</span> <span class="s2">&quot;f returned: &quot;</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="nb">lambda</span> <span class="p">{</span> <span class="s2">&quot;Value from lambda&quot;</span> <span class="p">})</span>
<span class="k">def</span> <span class="nf">another_method</span>
    <span class="s2">&quot;Value from method&quot;</span>
<span class="k">end</span>
<span class="nb">puts</span> <span class="s2">&quot;f returned: &quot;</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="nb">method</span><span class="p">(</span><span class="ss">:another_method</span><span class="p">))</span>

<span class="c1"># But put in a &quot;return,&quot; and all hell breaks loose!</span>
<span class="c1"># 但是加上一个“return”语句，一切都变的不可收拾。</span>

<span class="n">example</span> <span class="mi">10</span>

<span class="k">begin</span>
    <span class="n">f</span><span class="p">(</span><span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="k">return</span> <span class="s2">&quot;Value from Proc.new&quot;</span> <span class="p">})</span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="nb">puts</span> <span class="s2">&quot;Failed with </span><span class="si">#{</span><span class="n">e</span><span class="o">.</span><span class="n">class</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">end</span>

<span class="c1"># The call fails because that &quot;return&quot; needs to be inside a function, and a Proc isn&#39;t really</span>
<span class="c1"># quite a full-fledged function:</span>
<span class="c1"># 这样的调用会抛出异常因为“return”必须在一个函数内，而一个Proc不是一个真正的完全独立的函数。</span>

<span class="n">example</span> <span class="mi">11</span>

<span class="k">def</span> <span class="nf">g</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="k">return</span> <span class="s2">&quot;Value from Proc.new&quot;</span> <span class="p">})</span>
    <span class="nb">puts</span> <span class="s2">&quot;f returned: &quot;</span> <span class="o">+</span> <span class="n">result</span> <span class="c1">#never executed</span>
    <span class="s2">&quot;Value from g&quot;</span>               <span class="c1">#never executed</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="s2">&quot;g returned: </span><span class="si">#{</span><span class="n">g</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># Note that the return inside the &quot;Proc.new&quot; didn&#39;t just return from the Proc -- it returned</span>
<span class="c1"># all the way out of g, bypassing not only the rest of g but the rest of f as well! It worked</span>
<span class="c1"># almost like an exception.</span>
<span class="c1">#</span>
<span class="c1"># This means that it&#39;s not possible to call a Proc containing a &quot;return&quot; when the creating</span>
<span class="c1"># context no longer exists:</span>
<span class="c1"># 注意在“Proc.new”中的return语句不仅仅从Proc中返回，它将从g方法中返回，不仅绕过g方法中剩余的代码</span>
<span class="c1"># 而且f方法中也是一样的!它就像一个异常一样。</span>
<span class="c1">#</span>
<span class="c1"># 这意味着当创建Proc的上下文不存在时，无法调用一个包含“return”的Proc</span>
<span class="c1">#</span>
<span class="c1"># 本人的理解：</span>
<span class="c1"># 在Proc.new中的return语句，会尝试返回到创建它的上下文之后，继续执行，如果创建它的上下文已经“消失”或者返回到了全局上下文，就会出现LocalJumpError。</span>
<span class="c1"># </span>
<span class="c1"># 在#example10中，在全局上下文中用Proc.new创建了一个proc，在f方法中使用call，然后proc会返回到创建它的上下文，即全局上下文，于是出了LocalJumpError。</span>
<span class="c1"># 在#example11中，在g方法的上下文中用Proc.new创建了一个proc，在f方法中使用call，然后proc会返回到创建它的上下文，即g方法之后，这种情况不会出异常。</span>

<span class="n">example</span> <span class="mi">12</span>

<span class="k">def</span> <span class="nf">make_proc_new</span>
    <span class="k">begin</span>
        <span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="k">return</span> <span class="s2">&quot;Value from Proc.new&quot;</span> <span class="p">}</span> <span class="c1"># this &quot;return&quot; will return from make_proc_new 这个“return”会返回到make_proc_new方法之外</span>
    <span class="k">ensure</span>
        <span class="nb">puts</span> <span class="s2">&quot;make_proc_new exited&quot;</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="k">begin</span>
    <span class="nb">puts</span> <span class="n">make_proc_new</span><span class="o">.</span><span class="n">call</span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="nb">puts</span> <span class="s2">&quot;Failed with </span><span class="si">#{</span><span class="n">e</span><span class="o">.</span><span class="n">class</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">end</span>

<span class="c1"># (Note that this makes it unsafe to pass Procs across threads.)</span>
<span class="c1"># （注意跨先辰的传递Proc会导致它不安全。）</span>

<span class="c1"># A Proc.new, then, is not quite truly closed: it depends in the creating context still existing,</span>
<span class="c1"># because the &quot;return&quot; is tied to that context.</span>
<span class="c1"># Proc.new，不是一个真正完全的闭包。它依赖于创建它的上下文要一直存在，因为“return”和那个上下文联席在了一起。</span>
<span class="c1">#</span>
<span class="c1"># 本人的理解：</span>
<span class="c1"># 就和刚刚讲的一样，如果创建它的上下文已经“消失”，在这里make_proc_new方法把创建的proc返回了出去，所以make_proc_new的上下文就不存在了，</span>
<span class="c1"># 这时候再使用call，也会发生LocalJumpError。</span>
<span class="c1">#</span>
<span class="c1"># Not so for lambda:</span>
<span class="c1"># lambda就不是这个样子：</span>

<span class="n">example</span> <span class="mi">13</span>

<span class="k">def</span> <span class="nf">g</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="nb">lambda</span> <span class="p">{</span> <span class="k">return</span> <span class="s2">&quot;Value from lambda&quot;</span> <span class="p">})</span>
    <span class="nb">puts</span> <span class="s2">&quot;f returned: &quot;</span> <span class="o">+</span> <span class="n">result</span>
    <span class="s2">&quot;Value from g&quot;</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="s2">&quot;g returned: </span><span class="si">#{</span><span class="n">g</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># And yes, you can call a lambda even when the creating context is gone:</span>
<span class="c1"># 你可以调用lambda，即使创建它的上下文已经不在。</span>

<span class="n">example</span> <span class="mi">14</span>

<span class="k">def</span> <span class="nf">make_lambda</span>
    <span class="k">begin</span>
        <span class="nb">lambda</span> <span class="p">{</span> <span class="k">return</span> <span class="s2">&quot;Value from lambda&quot;</span> <span class="p">}</span>
    <span class="k">ensure</span>
        <span class="nb">puts</span> <span class="s2">&quot;make_lambda exited&quot;</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">make_lambda</span><span class="o">.</span><span class="n">call</span>

<span class="c1"># Inside a lambda, a return statement only returns from the lambda, and flow continues normally.</span>
<span class="c1"># So a lambda is like a function unto itself, whereas a Proc remains dependent on the control</span>
<span class="c1"># flow of its caller.</span>
<span class="c1"># 在lambda内部，return语句仅仅从lambda中返回，代码流程不会改变。</span>
<span class="c1"># 所以lambda就像一个方法一样，而Proc需要依赖于它调用者的控制流。(擦 什么烂翻译</span>
<span class="c1">#</span>
<span class="c1"># A lambda, therefore, is Ruby&#39;s true closure.</span>
<span class="c1"># 所以lambda才是ruby真正的闭包。</span>
<span class="c1">#</span>
<span class="c1"># As it turns out, &quot;proc&quot; is a synonym for either &quot;Proc.new&quot; or &quot;lambda.&quot;</span>
<span class="c1"># Anybody want to guess which one? (Hint: &quot;Proc&quot; in lowercase is &quot;proc.&quot;)</span>
<span class="c1"># 事实证明，&quot;proc&quot;是“Proc.new”或者“lambda”的同义词。</span>
<span class="c1"># 有人想猜一猜到底是哪个吗？（提示：“Proc”的小写是“proc”。）</span>

<span class="n">example</span> <span class="mi">15</span>

<span class="k">def</span> <span class="nf">g</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="nb">proc</span> <span class="p">{</span> <span class="k">return</span> <span class="s2">&quot;Value from proc&quot;</span> <span class="p">})</span>
    <span class="nb">puts</span> <span class="s2">&quot;f returned: &quot;</span> <span class="o">+</span> <span class="n">result</span>
    <span class="s2">&quot;Value from g&quot;</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="s2">&quot;g returned: </span><span class="si">#{</span><span class="n">g</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># Hah. Fooled you.</span>
<span class="c1"># 哈哈，你被耍了。</span>
<span class="c1">#</span>
<span class="c1"># The answer: Ruby changed its mind. If you&#39;re using Ruby 1.8, it&#39;s a synonym for &quot;lambda.&quot;</span>
<span class="c1"># That&#39;s surprising (and also ridiculous); somebody figured this out, so in 1.9, it&#39;s a synonym for</span>
<span class="c1"># Proc.new. Go figure.</span>
<span class="c1"># 答案是如果你使用ruby1.8，那么它是“lambda”的同义词。</span>
<span class="c1"># 这真得让人惊讶（而且荒谬），有些人指出了这一点，所以在ruby1.9，它是“Proc.new”的同义词了。</span>

<span class="c1"># I&#39;ll spare you the rest of the experiments, and give you the behavior of all 7 cases:</span>
<span class="c1"># 我就不进行剩下的实验了，但是会给出所有的7种示例。</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># &quot;return&quot; returns from caller:</span>
<span class="c1">#      1. block (called with yield)</span>
<span class="c1">#      2. block (&amp;b  =&gt;  f(&amp;b)  =&gt;  yield)  </span>
<span class="c1">#      3. block (&amp;b  =&gt;  b.call)    </span>
<span class="c1">#      4. Proc.new</span>
<span class="c1">#      5. proc in 1.9</span>
<span class="c1">#</span>
<span class="c1"># &quot;return&quot; only returns from closure:</span>
<span class="c1">#      5. proc in 1.8</span>
<span class="c1">#      6. lambda    </span>
<span class="c1">#      7. method</span>

<span class="c1"># ---------------------------- Section 4: Closures and Arity ----------------------------</span>
<span class="c1"># --------------------------------- 章节四：闭包和元数 ----------------------------------</span>
<span class="c1">#</span>
<span class="c1"># 注：arity =&gt; 一个方法或者函数可以接受的参数个数</span>

<span class="c1"># The other major distinguishing of different kinds of Ruby closures is how they handle mismatched</span>
<span class="c1"># arity -- in other words, the wrong number of arguments.</span>
<span class="c1"># 另外一个主要辨别不同种类的ruby闭包是他们如何处理不匹配的元数，换句话说，就是不正确的参数个数。</span>
<span class="c1">#</span>
<span class="c1"># In addition to &quot;call,&quot; every closure has an &quot;arity&quot; method which returns the number of expected</span>
<span class="c1"># arguments:</span>
<span class="c1"># 除了“call”以外，每个闭包还有一个“arity”方法可以返回期望的参数个数。</span>

<span class="n">example</span> <span class="mi">16</span>

<span class="nb">puts</span> <span class="s2">&quot;One-arg lambda:&quot;</span>
<span class="nb">puts</span> <span class="p">(</span><span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="p">}</span><span class="o">.</span><span class="n">arity</span><span class="p">)</span>
<span class="nb">puts</span> <span class="s2">&quot;Three-arg lambda:&quot;</span>
<span class="nb">puts</span> <span class="p">(</span><span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="o">|</span><span class="p">}</span><span class="o">.</span><span class="n">arity</span><span class="p">)</span>

<span class="c1"># ...well, sort of:</span>

<span class="nb">puts</span> <span class="s2">&quot;No-args lambda: &quot;</span>
<span class="nb">puts</span> <span class="p">(</span><span class="nb">lambda</span> <span class="p">{}</span><span class="o">.</span><span class="n">arity</span><span class="p">)</span> <span class="c1"># This behavior is also subject to change in 1.9. #这个行为在1.9中也会有变化。 1.8中是-1，1.9中是0</span>
<span class="nb">puts</span> <span class="s2">&quot;Varargs lambda: &quot;</span>
<span class="nb">puts</span> <span class="p">(</span><span class="nb">lambda</span> <span class="p">{</span><span class="o">|*</span><span class="n">args</span><span class="o">|</span><span class="p">}</span><span class="o">.</span><span class="n">arity</span><span class="p">)</span>

<span class="c1"># Watch what happens when we call these with the wrong number of arguments:</span>
<span class="c1"># 看看当我们使用不真确的参数个数来调用他们时，会发生什么。</span>

<span class="n">example</span> <span class="mi">17</span>

<span class="k">def</span> <span class="nf">call_with_too_many_args</span><span class="p">(</span><span class="n">closure</span><span class="p">)</span>
    <span class="k">begin</span>
        <span class="nb">puts</span> <span class="s2">&quot;closure arity: </span><span class="si">#{</span><span class="n">closure</span><span class="o">.</span><span class="n">arity</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">closure</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
        <span class="nb">puts</span> <span class="s2">&quot;Too many args worked&quot;</span>
    <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
        <span class="nb">puts</span> <span class="s2">&quot;Too many args threw exception </span><span class="si">#{</span><span class="n">e</span><span class="o">.</span><span class="n">class</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">two_arg_method</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="k">end</span>

<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;Proc.new:&quot;</span><span class="p">;</span> <span class="n">call_with_too_many_args</span><span class="p">(</span><span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">|</span><span class="p">})</span>
<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;proc:&quot;</span>    <span class="p">;</span> <span class="n">call_with_too_many_args</span><span class="p">(</span><span class="nb">proc</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">|</span><span class="p">})</span>
<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;lambda:&quot;</span>  <span class="p">;</span> <span class="n">call_with_too_many_args</span><span class="p">(</span><span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">|</span><span class="p">})</span>
<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;Method:&quot;</span>  <span class="p">;</span> <span class="n">call_with_too_many_args</span><span class="p">(</span><span class="nb">method</span><span class="p">(</span><span class="ss">:two_arg_method</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">call_with_too_few_args</span><span class="p">(</span><span class="n">closure</span><span class="p">)</span>
    <span class="k">begin</span>
        <span class="nb">puts</span> <span class="s2">&quot;closure arity: </span><span class="si">#{</span><span class="n">closure</span><span class="o">.</span><span class="n">arity</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">closure</span><span class="o">.</span><span class="n">call</span><span class="p">()</span>
        <span class="nb">puts</span> <span class="s2">&quot;Too few args worked&quot;</span>
    <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
        <span class="nb">puts</span> <span class="s2">&quot;Too few args threw exception </span><span class="si">#{</span><span class="n">e</span><span class="o">.</span><span class="n">class</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;Proc.new:&quot;</span><span class="p">;</span> <span class="n">call_with_too_few_args</span><span class="p">(</span><span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">|</span><span class="p">})</span>
<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;proc:&quot;</span>    <span class="p">;</span> <span class="n">call_with_too_few_args</span><span class="p">(</span><span class="nb">proc</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">|</span><span class="p">})</span>
<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;lambda:&quot;</span>  <span class="p">;</span> <span class="n">call_with_too_few_args</span><span class="p">(</span><span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">|</span><span class="p">})</span>
<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;Method:&quot;</span>  <span class="p">;</span> <span class="n">call_with_too_few_args</span><span class="p">(</span><span class="nb">method</span><span class="p">(</span><span class="ss">:two_arg_method</span><span class="p">))</span>

<span class="c1"># Yet oddly, the behavior for one-argument closures is different....</span>
<span class="c1"># 奇怪的是，当闭包只有一个参数时，它们的行为又不一样了。。。</span>

<span class="n">example</span> <span class="mi">18</span>

<span class="k">def</span> <span class="nf">one_arg_method</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">end</span>

<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;Proc.new:&quot;</span><span class="p">;</span> <span class="n">call_with_too_many_args</span><span class="p">(</span><span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="p">})</span>
<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;proc:&quot;</span>    <span class="p">;</span> <span class="n">call_with_too_many_args</span><span class="p">(</span><span class="nb">proc</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="p">})</span>
<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;lambda:&quot;</span>  <span class="p">;</span> <span class="n">call_with_too_many_args</span><span class="p">(</span><span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="p">})</span>
<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;Method:&quot;</span>  <span class="p">;</span> <span class="n">call_with_too_many_args</span><span class="p">(</span><span class="nb">method</span><span class="p">(</span><span class="ss">:one_arg_method</span><span class="p">))</span>
<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;Proc.new:&quot;</span><span class="p">;</span> <span class="n">call_with_too_few_args</span><span class="p">(</span><span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="p">})</span>
<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;proc:&quot;</span>    <span class="p">;</span> <span class="n">call_with_too_few_args</span><span class="p">(</span><span class="nb">proc</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="p">})</span>
<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;lambda:&quot;</span>  <span class="p">;</span> <span class="n">call_with_too_few_args</span><span class="p">(</span><span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="p">})</span>
<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;Method:&quot;</span>  <span class="p">;</span> <span class="n">call_with_too_few_args</span><span class="p">(</span><span class="nb">method</span><span class="p">(</span><span class="ss">:one_arg_method</span><span class="p">))</span>

<span class="c1"># Yet when there are no args...</span>
<span class="c1"># 当他们没有参数时。。。</span>

<span class="n">example</span> <span class="mi">19</span>

<span class="k">def</span> <span class="nf">no_arg_method</span>
<span class="k">end</span>

<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;Proc.new:&quot;</span><span class="p">;</span> <span class="n">call_with_too_many_args</span><span class="p">(</span><span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span><span class="o">||</span><span class="p">})</span>
<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;proc:&quot;</span>    <span class="p">;</span> <span class="n">call_with_too_many_args</span><span class="p">(</span><span class="nb">proc</span> <span class="p">{</span><span class="o">||</span><span class="p">})</span>
<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;lambda:&quot;</span>  <span class="p">;</span> <span class="n">call_with_too_many_args</span><span class="p">(</span><span class="nb">lambda</span> <span class="p">{</span><span class="o">||</span><span class="p">})</span>
<span class="nb">puts</span><span class="p">;</span> <span class="nb">puts</span> <span class="s2">&quot;Method:&quot;</span>  <span class="p">;</span> <span class="n">call_with_too_many_args</span><span class="p">(</span><span class="nb">method</span><span class="p">(</span><span class="ss">:no_arg_method</span><span class="p">))</span>

<span class="c1"># For no good reason that I can see, Proc.new, proc and lambda treat a single argument as a special</span>
<span class="c1"># case; only a method enforces arity in all cases. Principle of least surprise my ass.</span>
<span class="c1"># 没办法解释你和我看到的结果，Proc.new，proc和lambda在面对一个参数时有特殊的处理；</span>
<span class="c1"># 只有method在任何情况下都强制执行了参数的个数。真是草尼马的最小惊讶原则。</span>
<span class="c1">#</span>
<span class="c1"># 注：#example17-19的结果在ruby1.8和1.9下，1.8下proc和lambda的执行结果完全一样，1.9下proc和Proc.new的结果完全相同。</span>


<span class="c1"># ---------------------------- Section 5: Rant ----------------------------</span>
<span class="c1"># ------------------------------ 章节五：咆哮 -----------------------------</span>
<span class="c1">#</span>
<span class="c1"># This is quite a dizzing array of syntactic options, with subtle semantics differences that are not</span>
<span class="c1"># at all obvious, and riddled with minor special cases. It&#39;s like a big bear trap from programmers who</span>
<span class="c1"># expect the language to just work.</span>
<span class="c1"># 真是让人蛋疼的语法，这些语法上的微妙差异不是那么显而易见的，而且还有不少小的特殊情况。</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># Why are things this way? Because Ruby is:</span>
<span class="c1"># 为什么会这样呢？因为ruby是：</span>
<span class="c1">#</span>
<span class="c1">#   (1) designed by implementation, and</span>
<span class="c1">#   (2) defined by implementation.</span>
<span class="c1">#   通过实现来设计和定义 （看不明白</span>
<span class="c1">#</span>
<span class="c1"># The language grows because the Ruby team tacks on cool ideas, without maintaining a real spec apart</span>
<span class="c1"># from CRuby. A spec would make clear the logical structure of the language, and thus help highlight</span>
<span class="c1"># inconsistencies like the ones we&#39;ve just seen. Instead, these inconsinstencies creep into the language,</span>
<span class="c1"># confuse the crap out of poor souls like me who are trying to learn it, and then get submitted as bug</span>
<span class="c1"># reports. Something as fundamental as the semantics of proc should not get so screwed up that they have</span>
<span class="c1"># to backtrack between releases, for heaven&#39;s sake! Yes, I know, language design is hard -- but something</span>
<span class="c1"># like this proc/lambda issue or the arity problem wasn&#39;t so hard to get right the first time.</span>
<span class="c1"># Yammer yammer.</span>
<span class="c1"># （此处省略原作者抱怨的100字。。。）</span>


<span class="c1"># ---------------------------- Section 6: Summary ----------------------------</span>
<span class="c1"># ------------------------------- 章节六：总结 -------------------------------</span>
<span class="c1">#</span>
<span class="c1"># So, what&#39;s the final verdict on those 7 closure-like entities?          </span>
<span class="c1"># 所以，那7个闭包风格的实体最终结论如下：</span>
<span class="c1">#</span>
<span class="c1">#                                                     &quot;return&quot; returns from closure</span>
<span class="c1">#                                    True closure?    or declaring context...?         Arity check?</span>
<span class="c1">#                                    ---------------  -----------------------------    -------------------</span>
<span class="c1"># 1. block (called with yield)       N                declaring                        no</span>
<span class="c1"># 2. block (&amp;b =&gt; f(&amp;b) =&gt; yield)    N                declaring                        no</span>
<span class="c1"># 3. block (&amp;b =&gt; b.call)            Y except return  declaring                        warn on too few</span>
<span class="c1"># 4. Proc.new                        Y except return  declaring                        warn on too few</span>
<span class="c1"># 5. proc                                    &lt;&lt;&lt; alias for lambda in 1.8, Proc.new in 1.9 &gt;&gt;&gt;</span>
<span class="c1"># 6. lambda                          Y                closure                          yes, except arity 1</span>
<span class="c1"># 7. method                          Y                closure                          yes</span>
<span class="c1">#</span>
<span class="c1"># The things within each of these groups are all semantically identical -- that is, they&#39;re different</span>
<span class="c1"># syntaxes for the same thing:</span>
<span class="c1"># 下面的分组中的每个在语义上都是相同的，也就是说，只是语法不同的同一个东西。</span>
<span class="c1">#   </span>
<span class="c1">#      1. block (called with yield)</span>
<span class="c1">#      2. block (&amp;b  =&gt;  f(&amp;b)  =&gt;  yield)  </span>
<span class="c1">#      -------</span>
<span class="c1">#      3. block (&amp;b  =&gt;  b.call)</span>
<span class="c1">#      4. Proc.new  </span>
<span class="c1">#      5. proc in 1.9</span>
<span class="c1">#      -------</span>
<span class="c1">#      5. proc in 1.8</span>
<span class="c1">#      6. lambda    </span>
<span class="c1">#      -------</span>
<span class="c1">#      7. method (may be identical to lambda with changes to arity checking in 1.9) 在1.9中参数检查和lambda一样</span>
<span class="c1">#</span>
<span class="c1"># Or at least, this is how I *think* it is, based on experiment. There&#39;s no authoritative answer other</span>
<span class="c1"># than testing the CRuby implementation, because there&#39;s no real spec -- so there may be other differences</span>
<span class="c1"># I haven&#39;t discovered.</span>
<span class="c1"># 至少，根据实验，我是这么认为的。除了测试CRuby实现外，也没有其他的官方答案。因为没有真实的规范--所以也许和我发现的有些不同。</span>
<span class="c1">#</span>
<span class="c1"># The final verdict: Ruby has four types of closures and near-closures, expressible in seven syntactic</span>
<span class="c1"># variants. Not pretty. But you sure sure do cool stuff with them! That&#39;s up next....</span>
<span class="c1"># 最终结论：Ruby有四个类型的闭包和近似闭包，使用7中语法变形来体现，不是很好，但是你能他们来做一些很cool的东西。</span>
<span class="c1">#</span>
<span class="c1"># This concludes the &quot;Ruby sucks&quot; portion of our broadcast; from here on, it will be the &quot;Ruby is</span>
<span class="c1"># awesome&quot; portion.</span>


<span class="c1"># ---------------------------- Section 7: Doing Something Cool with Closures ----------------------------</span>
<span class="c1"># ----------------------------------- 章节七：用闭包来做些Cool的东西 ------------------------------------</span>

<span class="c1"># Let&#39;s make a data structure containing all of the Fibonacci numbers. Yes, I said *all* of them.</span>
<span class="c1"># How is this possible? We&#39;ll use closures to do lazy evaluation, so that the computer only calculates</span>
<span class="c1"># as much of the list as we ask for.</span>
<span class="c1"># 我们创建一个数据结构包含所有的菲波那契数。是的，我说“所有的”。</span>
<span class="c1"># 这怎么可能？我们将使用闭包来做到延迟求值，所以计算机仅仅会计算我们所要的。</span>

<span class="c1"># To make this work, we&#39;re going to use Lisp-style lists: a list is a recursive data structure with</span>
<span class="c1"># two parts: &quot;car,&quot; the next element of the list, and &quot;cdr,&quot; the remainder of the list.</span>
<span class="c1"># 要让他工作，我们要使用Lisp风格的lists：一个包含2部分的可递归的数据结构：“car”，list中的下一个元素，“cdr”，list中剩余的元素。</span>
<span class="c1">#</span>
<span class="c1"># For example, the list of the first three positive integers is [1,[2,[3]]]. Why? Because:</span>
<span class="c1">#</span>
<span class="c1">#   [1,[2,[3]]]     &lt;--- car=1, cdr=[2,[3]]</span>
<span class="c1">#      [2,[3]]      &lt;--- car=2, cdr=[3]</span>
<span class="c1">#         [3]       &lt;--- car=3, cdr=nil</span>
<span class="c1">#</span>
<span class="c1"># Here&#39;s a class for traversing such lists:</span>
<span class="c1"># 这有一个类来遍历这样的list</span>

<span class="n">example</span> <span class="mi">20</span>

<span class="k">class</span> <span class="nc">LispyEnumerable</span>
    <span class="kp">include</span> <span class="no">Enumerable</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="vi">@tree</span> <span class="o">=</span> <span class="n">tree</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">each</span>
        <span class="k">while</span> <span class="vi">@tree</span>
            <span class="n">car</span><span class="p">,</span><span class="n">cdr</span> <span class="o">=</span> <span class="vi">@tree</span>
            <span class="k">yield</span> <span class="n">car</span>
            <span class="vi">@tree</span> <span class="o">=</span> <span class="n">cdr</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="n">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="o">[</span><span class="mi">2</span><span class="p">,</span><span class="o">[</span><span class="mi">3</span><span class="o">]]]</span>
<span class="no">LispyEnumerable</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">list</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="n">x</span>
<span class="k">end</span>

<span class="c1"># So how to make an infinite list? Instead of making each node in the list a fully built</span>
<span class="c1"># data structure, we&#39;ll make it a closure -- and then we won&#39;t call that closure</span>
<span class="c1"># until we actually need the value. This applies recursively: the top of the tree is a closure,</span>
<span class="c1"># and its cdr is a closure, and the cdr&#39;s cdr is a closure....</span>
<span class="c1"># 所以如和去创建一个无限的list？我们通过创建一个闭包来代替原来在list中内建的基本数据结构。</span>
<span class="c1"># 除非我们真得须要数据，否则我们不会调用它。它会是一个递归。。。</span>

<span class="n">example</span> <span class="mi">21</span>

<span class="k">class</span> <span class="nc">LazyLispyEnumerable</span>
    <span class="kp">include</span> <span class="no">Enumerable</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="vi">@tree</span> <span class="o">=</span> <span class="n">tree</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">each</span>
        <span class="k">while</span> <span class="vi">@tree</span>
            <span class="n">car</span><span class="p">,</span><span class="n">cdr</span> <span class="o">=</span> <span class="vi">@tree</span><span class="o">.</span><span class="n">call</span> <span class="c1"># &lt;--- @tree is a closure</span>
            <span class="k">yield</span> <span class="n">car</span>
            <span class="vi">@tree</span> <span class="o">=</span> <span class="n">cdr</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="n">list</span> <span class="o">=</span> <span class="nb">lambda</span><span class="p">{</span><span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">lambda</span> <span class="p">{</span><span class="o">[</span><span class="mi">2</span><span class="p">,</span> <span class="nb">lambda</span> <span class="p">{</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="p">}</span><span class="o">]</span><span class="p">}</span><span class="o">]</span><span class="p">}</span> <span class="c1"># same as above, except we wrap each level in a lambda 和前面的一样，只是多包了一个lambda</span>
<span class="no">LazyLispyEnumerable</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">list</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="n">x</span>
<span class="k">end</span>

<span class="n">example</span> <span class="mi">22</span>

<span class="c1"># Let&#39;s see when each of those blocks gets called:</span>
<span class="c1"># 让我们来看看这些block是什么时候被调用的</span>
<span class="n">list</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="k">do</span>
    <span class="nb">puts</span> <span class="s2">&quot;first lambda called&quot;</span>
    <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">lambda</span> <span class="k">do</span>
        <span class="nb">puts</span> <span class="s2">&quot;second lambda called&quot;</span>
        <span class="o">[</span><span class="mi">2</span><span class="p">,</span> <span class="nb">lambda</span> <span class="k">do</span>
            <span class="nb">puts</span> <span class="s2">&quot;third lambda called&quot;</span>
            <span class="o">[</span><span class="mi">3</span><span class="o">]</span>
        <span class="k">end</span><span class="o">]</span>
    <span class="k">end</span><span class="o">]</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="s2">&quot;List created; about to iterate:&quot;</span>
<span class="no">LazyLispyEnumerable</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">list</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="n">x</span>
<span class="k">end</span>


<span class="c1"># Now, because the lambda defers evaluation, we can make an infinite list:</span>
<span class="c1"># 现在，因为lamdba的延迟求值，我们可以创建无限list。</span>

<span class="n">example</span> <span class="mi">23</span>

<span class="k">def</span> <span class="nf">fibo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
    <span class="nb">lambda</span> <span class="p">{</span> <span class="o">[</span><span class="n">a</span><span class="p">,</span> <span class="n">fibo</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">]</span> <span class="p">}</span> <span class="c1"># &lt;---- this would go into infinite recursion if it weren&#39;t in a lambda 这个会进入死循环如果它不在lambda内部</span>
<span class="k">end</span>

<span class="no">LazyLispyEnumerable</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">fibo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="n">x</span>
    <span class="k">break</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="c1"># we don&#39;t actually want to print all of the Fibonaccis! 我们实际上不会要打印所有的菲波那契数。</span>
<span class="k">end</span>

<span class="c1"># This kind of deferred execution is called &quot;lazy evaluation&quot; -- as opposed to the &quot;eager</span>
<span class="c1"># evaluation&quot; we&#39;re used to, where we evaluate an expression before passing its value on.</span>
<span class="c1"># (Most languages, including Ruby, use eager evaluation, but there are languages (like Haskell)</span>
<span class="c1"># which use lazy evaluation for everything, by default! Not always performant, but ever so very cool.)</span>
<span class="c1"># 这就是延迟求值，和我们通常用得立即求值相反，我们在传送值之前就求值了表达式。</span>
<span class="c1"># 大部分语言，包括ruby，都是立即求值，但是有些其他语言，比如Haskell，他默认就是对任何都延迟求值。</span>
<span class="c1"># 这不是一直是高性能的，但是这非常cool。</span>
<span class="c1">#</span>
<span class="c1"># This way of implementing lazy evaluation is terribly clunky! We had to write a separate</span>
<span class="c1"># LazyLispyEnumerable that *knows* we&#39;re passing it a special lazy data structure. How unsatisfying!</span>
<span class="c1"># Wouldn&#39;t it be nice of the lazy evaluation were invisible to callers of the lazy object?</span>
<span class="c1"># 这种实现延迟求值的方式是非常笨拙的。我们不得不写一个单独的LazyLispyEnumerable，让他知道我们传了一个</span>
<span class="c1"># 特别的延迟数据结构给他。能不能让他更好的处理延迟求值，让他对于调用者隐藏延迟对象？</span>
<span class="c1">#</span>
<span class="c1"># As it turns out, we can do this. We&#39;ll define a class called &quot;Lazy,&quot; which takes a block, turns it</span>
<span class="c1"># into a closure, and holds onto it without immediately calling it. The first time somebody calls a</span>
<span class="c1"># method, we evaluate the closure and then forward the method call on to the closure&#39;s result.</span>
<span class="c1"># 事实证明，我们可以这么做。我们定一个叫“Lazy”的类，然后使用block，把它转成闭包，然后保存它。</span>
<span class="c1"># 第一次一些人调用了它，我们求取闭包的值，然后跳转到下一个方法调用。</span>

<span class="k">class</span> <span class="nc">Lazy</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">generator</span><span class="p">)</span>
        <span class="vi">@generator</span> <span class="o">=</span> <span class="n">generator</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
        <span class="n">evaluate</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">evaluate</span>
        <span class="vi">@value</span> <span class="o">=</span> <span class="vi">@generator</span><span class="o">.</span><span class="n">call</span> <span class="k">unless</span> <span class="vi">@value</span>
        <span class="vi">@value</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">lazy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="no">Lazy</span><span class="o">.</span><span class="n">new</span> <span class="o">&amp;</span><span class="n">b</span>
<span class="k">end</span>

<span class="c1"># This basically allows us to say:</span>
<span class="c1"># 你可以这样来使用：</span>
<span class="c1">#</span>
<span class="c1">#   lazy {value}</span>
<span class="c1"># </span>
<span class="c1"># ...and get an object that *looks* exactly like value -- except that value won&#39;t be created until the</span>
<span class="c1"># first method call that touches it. It creates a transparent lazy proxy object. Observe:</span>
<span class="c1"># 。。。然后就能得到一个看起来像指定的value一样的对象—— 除了value只有在一次调用method的以后才会创建。</span>
<span class="c1"># 它创建了一个透明的延迟代理对象。</span>

<span class="n">example</span> <span class="mi">24</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">lazy</span> <span class="k">do</span>
    <span class="nb">puts</span> <span class="s2">&quot;&lt;&lt;&lt; Evaluating lazy value &gt;&gt;&gt;&quot;</span>
    <span class="s2">&quot;lazy value&quot;</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="s2">&quot;x has now been assigned&quot;</span>
<span class="nb">puts</span> <span class="s2">&quot;About to call one of x&#39;s methods:&quot;</span>
<span class="nb">puts</span> <span class="s2">&quot;x.size: </span><span class="si">#{</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span>          <span class="c1"># &lt;--- .size triggers lazy evaluation .size会触发延迟求值</span>
<span class="nb">puts</span> <span class="s2">&quot;x.swapcase: </span><span class="si">#{</span><span class="n">x</span><span class="o">.</span><span class="n">swapcase</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># So now, if we define fibo using lazy instead of lambda, it should magically work with our</span>
<span class="c1"># original LispyEnumerable -- which has no idea it&#39;s dealing with a lazy value! Right?</span>
<span class="c1"># 现在，我们使用lazy代替lambda来创建菲波那契函数，它应该可以神奇地和我们来原的LispyEnumerable工作。</span>
<span class="c1"># LispyEnumerable并不知道如何处理一个lazy value！是不是？</span>

<span class="n">example</span> <span class="mi">25</span>

<span class="k">def</span> <span class="nf">fibo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
    <span class="n">lazy</span> <span class="p">{</span> <span class="o">[</span><span class="n">a</span><span class="p">,</span> <span class="n">fibo</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">]</span> <span class="p">}</span>
<span class="k">end</span>

<span class="no">LispyEnumerable</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">fibo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="n">x</span>
    <span class="k">break</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">instance_of?</span><span class="p">(</span><span class="no">Lazy</span><span class="p">)</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">200</span>
<span class="k">end</span>

<span class="c1"># 这个方法在ruby 1.8和1.9中不一样</span>
<span class="c1"># 1.8中会调用respond_to?(to_a)方法来找to_a，而respond_to又是Object的方法，每个对象都会有，所以不会经过method_missing</span>
<span class="c1"># 1.9中会直接调用method_missing(to_a)方法来找to_a</span>
<span class="c1"># 所以1.8只会打印出一个Lazy对象，而1.9中可以顺利执行</span>

<span class="c1"># Oops! That didn&#39;t work. What went wrong?</span>
<span class="c1"># 噢，它并没有如我们想的那样工作，哪里出错了？</span>
<span class="c1">#</span>
<span class="c1"># The failure started in this line of LispyEnumerable (though Ruby didn&#39;t report the error there):</span>
<span class="c1"># 错误发生在LispyEnumerable的这一行（尽管Ruby没有报错）</span>
<span class="c1">#</span>
<span class="c1">#      car,cdr = @tree</span>
<span class="c1">#</span>
<span class="c1"># Let&#39;s zoom in on that result, and see what happened:</span>
<span class="c1"># 让我们看看到底发生了什么！</span>

<span class="n">example</span> <span class="mi">26</span>

<span class="n">car</span><span class="p">,</span><span class="n">cdr</span> <span class="o">=</span> <span class="n">fibo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">puts</span> <span class="s2">&quot;car=</span><span class="si">#{</span><span class="n">car</span><span class="si">}</span><span class="s2">  cdr=</span><span class="si">#{</span><span class="n">cdr</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># Here&#39;s the problem. When we do this:</span>
<span class="c1"># 问题就在这里，当我们这样赋值时：</span>
<span class="c1">#</span>
<span class="c1">#   x,y = z</span>
<span class="c1">#</span>
<span class="c1"># ...Ruby calls z.respond_to?(to_a) to see if z is an array. If it is, it will do the multiple</span>
<span class="c1"># assignment; if not, it will just assign x=z and set y=nil.</span>
<span class="c1"># Ruby会调用z.respond_to?(to_a)来看看z是否能变成一个数组。如果可以，它会进行多次赋值，</span>
<span class="c1"># 否则，它只会赋值 x=z 和 y = nil。</span>
<span class="c1">#</span>
<span class="c1"># We want our Lazy to forward the respond_to? call to our fibo list. But it doesn&#39;t forward it,</span>
<span class="c1"># because we used the method_missing to do the proxying -- and every object implements respond_to?</span>
<span class="c1"># by default, so the method isn&#39;t missing! The respond_to? doesn&#39;t get forwarded; instead, out Lazy</span>
<span class="c1"># says &quot;No, I don&#39;t respond to to_a; thanks for asking.&quot; The immediate solution is to forward</span>
<span class="c1"># respond_to? manually:</span>
<span class="c1"># 我们想要的Lazy来转发respond_to?，让它调用到我们的菲波那契。但是它没有做到，因为我们用method_missing</span>
<span class="c1"># 来进行代理 -- 而每个对象默认都有respond_to?方法，所以无法触发到method_missing！respond_to?方法没有被转发，</span>
<span class="c1"># 所以Lazy说：“我没有to_a方法，谢谢你的调用。”最快捷的办法是手动转发respond_to?方法。</span>

<span class="k">class</span> <span class="nc">Lazy</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">generator</span><span class="p">)</span>
        <span class="vi">@generator</span> <span class="o">=</span> <span class="n">generator</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
        <span class="n">evaluate</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">respond_to?</span><span class="p">(</span><span class="nb">method</span><span class="p">)</span>
        <span class="n">evaluate</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="nb">method</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">evaluate</span>
        <span class="vi">@value</span> <span class="o">=</span> <span class="vi">@generator</span><span class="o">.</span><span class="n">call</span> <span class="k">unless</span> <span class="vi">@value</span>
        <span class="vi">@value</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># And *now* our original Lispy enum can work:</span>
<span class="c1"># 现在我们原来的Lispy enum就能工作了。</span>

<span class="n">example</span> <span class="mi">27</span>

<span class="no">LispyEnumerable</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">fibo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="n">x</span>
    <span class="k">break</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">200</span>
<span class="k">end</span>

<span class="c1"># Of course, this only fixes the problem for respond_to?, and we have the same problem for every other</span>
<span class="c1"># method of Object. There is a more robust solution -- frightening, but it works -- which is to undefine</span>
<span class="c1"># all the methods of the Lazy when it&#39;s created, so that everything gets forwarded.</span>
<span class="c1"># 当然，这只是修改了respond_to?的问题，Object的其他方法也有同样的问题。这里有一个更健壮的办法，虽然有点可怕，</span>
<span class="c1"># 但是它能工作。那就是在Lazy对象创建时取消定义Lazy所有的方法，那样就都能被转发了。</span>
<span class="c1">#</span>
<span class="c1"># And guess what? There&#39;s already a slick little gem that will do it:</span>
<span class="c1"># 其实已经有一个gem做了这样的事：</span>
<span class="c1">#</span>
<span class="c1">#     http://moonbase.rydia.net/software/lazy.rb/</span>
<span class="c1">#</span>
<span class="c1"># Read the source. It&#39;s fascinating.</span>
<span class="c1"># 看看它的源码把，非常让人着迷。</span>

<span class="c1"># ---------------------------- Section 8: Wrap-Up ----------------------------</span>
<span class="c1"># ------------------------------- 章节八：总结 -------------------------------</span>

<span class="c1"># So sure, this was all entertaining -- but is it good for anything?</span>
<span class="c1"># 这就是所有了 -- 那么是不是它有利于任何事？</span>
<span class="c1">#</span>
<span class="c1"># Well, suppose you have an object which requires a network or database call to be created, or will</span>
<span class="c1"># use a lot of memory once it exists. And suppose that it may or may not be used, but you don&#39;t know</span>
<span class="c1"># at the time it&#39;s created whether it will be. Making it lazy will prevent it from consuming resources</span>
<span class="c1"># unless it needs to. Hibernate does this to prevent unnecessary DB queries, and it does it with more or</span>
<span class="c1"># less arbitrary Java objects (i.e. unlike ActiveRecord, it doesn&#39;t depend on a base class to do its</span>
<span class="c1"># lazy loading). Ruby can do the same thing, but with a lot less code!</span>
<span class="c1"># 假设你有一个对象须要一个网络或者数据库的调用才能被创建，或者会一旦创建会占用大量内存。你也不知道什么</span>
<span class="c1"># 时候会用到它。使用lazy将防止它消耗资源，除非它真得需要。Hibernate使用延迟加载来阻止不必要的数据库查询，</span>
<span class="c1"># 而Hibernate做到它需要或多或少的Java对象。（不像ActiveRecord，它依赖于一个base class来做到延迟加载）</span>
<span class="c1"># Ruby可以使用更少的代码做到相同的事情。</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># That&#39;s just an example. Use your imagination.</span>
<span class="c1"># 这只是个示例，发挥你的想象力。</span>
<span class="c1">#</span>
<span class="c1"># If you&#39;re a functional langauge geek, and enjoyed seeing Ruby play with these ideas from Lisp and</span>
<span class="c1"># Haskell, you may enjoy this thread:</span>
<span class="c1"># 如果你是个函数式语言的极客，并且喜欢使用Ruby的这些来自于Lisp和Haskell的特性，你也许会想加入</span>
<span class="c1">#</span>
<span class="c1">#     http://redhanded.hobix.com/inspect/curryingWithArity.html</span>
<span class="c1">#</span>
<span class="c1"># OK, I&#39;ll stop making your brain hurt now. Hope this has been a bit enlightening! The experience</span>
<span class="c1"># of working it out certainly was for me.</span>
<span class="c1"># 好了，我不再伤害你的大脑了。希望这能够给你一点启发！理解这些的经验对我非常有用。</span>
<span class="c1">#</span>
<span class="c1"># Paul</span>
</code></pre></div>
    <nav class="article-previous fn-clear">
        
        <a class="prev" href="/blog//odoq/2015/07/22/ODOQ%20-%20private%20method%20in%20ruby.html" rel="bookmark">&laquo;&nbsp;One Day One Question -...</a>
        
        
        <a class="next" href="/blog//reading%20ruby/2015/07/23/Reading%20Ruby%20-%20Ruby%E4%B8%AD%E7%9A%84%E7%B1%BB%E7%BB%93%E6%9E%84.html" rel="bookmark">Reading Ruby - Ruby中的类结构&nbsp;&raquo;</a>
        
    </nav>
    <div class="comment">
        
            
        
    </div>
</div>


                    
                        <div id="disqus_thread"></div>
 <script type="text/javascript">
     /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
     var disqus_shortname = 'minixalpha'; // required: replace example with your forum shortname

     /* * * DON'T EDIT BELOW THIS LINE * * */
     (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
 </script>
 <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    

                    
                </div>
                <div class="aside">
                    <div class="aside-contact">
                        <h4 class="title">About me</h4>
                        <div class="det fn-clear">
                            <div class="det-image">
                                <img src="https://avatars.githubusercontent.com/soulspirit1229" />
                            </div>
                            <div class="det-text">
                                <p>我是 SoulSpirit</p>
                            </div>
                        </div>
                    </div>

                    <div class="aside-item">
                        <h4 class="title">Recent Posts</h4>
                        <ul class="list">
                            
                                <li><a href="/blog/reading%20ruby/2015/07/26/Reading%20Ruby%20-%20Class%20Methods.html" title="Reading Ruby - Class Methods" rel="bookmark">Reading Ruby - Class Methods</a></li>
                            
                                <li><a href="/blog/reading%20rails/2015/07/26/Reading%20Rails%20-%20Validation.html" title="Reading Rails - Rails Validation" rel="bookmark">Reading Rails - Rails Validation</a></li>
                            
                                <li><a href="/blog/reading%20rails/2015/07/26/Reading%20Rails%20-%20ActiveSupport%20delegation.html" title="Reading Rails - ActiveSupport delegation" rel="bookmark">Reading Rails - ActiveSupport delegation</a></li>
                            
                                <li><a href="/blog/reading%20rails/2015/07/26/Reading%20Rails%20-%20ActiveRecord.html" title="Reading Rails - Active Record" rel="bookmark">Reading Rails - Active Record</a></li>
                            
                                <li><a href="/blog/reading%20rails/2015/07/26/Reading%20Rails%20-%20ActiveModel%20Callbacks.html" title="Reading Rails - Active Model Callbacks" rel="bookmark">Reading Rails - Active Model Callbacks</a></li>
                            
                                <li><a href="/blog/reading%20rails/2015/07/26/Reading%20Rails%20-%20Active%20Model%20Validation.html" title="Reading Rails - Active Model Validation" rel="bookmark">Reading Rails - Active Model Validation</a></li>
                            
                        </ul>
                    </div>

                    <div class="aside-item">
                        <h4 class="title">Links</h4>
                        <ul class="list">
                            
                                
                                    
                                    <li><a href="http://www.zhanxin.info" title="掌心" target="_blank">掌心</a></li>
                                    
                                    <li><a href="http://jekyllrb.com" title="Jekyll" target="_blank">Jekyll</a></li>
                                    
                                    <li><a href="http://www.zhanxin.info/themes.html" title="Jekyll Theme" target="_blank">Jekyll Theme</a></li>
                                    
                                
                            
                                
                            
                        </ul>
                    </div>

                </div>
            </div>
        </div>
        <div class="foot">
            <div class="footer">
                <p>Copyright 2013. All rights reserved. Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>, Design by <a href="http://www.zhanxin.info" target="_blank">zhanxin.info</a>.</p>
            </div>
        </div>
        <script type="text/javascript" src="https://lib.sinaapp.com/js/jquery/1.8.3/jquery.min.js"></script>
        
    </body>
</html>
